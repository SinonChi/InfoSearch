польз  от  вложен  таблиц  ил  как  их  ещ  называ  дочерн  таблиц  nested  table  достаточн  сомнительн  по  двум  причин  для  тип  и  объект  нельз  созда  внешн  ключ  foreign  key  а  реализова  функциона  с  помощ  дополнительн  таблиц  очен  прост  и  можн  был  бы  найт  друг  достоинств  для  вложен  таблиц  есл  бы  не  тот  факт  что  посл  создан  основн  таблиц  колон  вложен  таблиц  измен  уж  нельз  можн  конечн  созда  втор  тип  и  использова  ег  но  эт  достаточн  больш  количеств  работ  и  несомнен  мног  беспокойств  о  уж  существ  дан  однак  у  мен  возникл  иде  о  реализац  взаимосвяз  многие-ко-мног  many-to-many  relationship  с  помощ  вложен  таблиц  вед  иде  так  заманчив    вмест  одн  внешн  ключ  хран  их  набор  для  конкретн  запис    что  может  быт  логичн  с  точк  зрен  человеческ  логик  но  тут  возник  вопрос    а  сто  ли  игр  свеч  пример  на  пример  прощ  показа  предлага  структур  а  такж  эт  хорош  способ  провер  как  способ  меньш  нагружа  сист  допуст  существ  автобусн  парк  сферическ  в  вакуум  у  автобусн  парк  ест  нескольк  автобус  и  нескольк  водител  на  одн  автобус  езд  нескольк  водител  нескольк  смен  особен  эт  парк  таков  что  один  водител  такж  может  езд  на  нескольк  автобус  например  в  зависим  от  дня  недел  создад  две  очен  прост  таблиц  предназначен  тольк  для  тог  чтоб  создава  межд  ним  взаимосвяз  create  table  tab_bus     b_id  number  primary  key     bus_number  varchar29  not  null     create  sequence  seq_bus  create  table  tab_driver     d_id  number  primary  key     driver_name  varchar2255  not  null     create  sequence  seq_driver    this  source  code  was  highlighted  with  source  code  highlighterдля  нача  реализу  взаимосвяз  использ  наибол  распространен  подход  создад  таблиц  взаимосвяз  create  table  bus_driver     bus_id  number     driver_id  number     constraint  pk_driver_bus  primary  key  bus_id  driver_id     constraint  fk_bus_id  foreign  key  bus_id  references  tab_bus  b_id     constraint  fk_driver_id  foreign  key  driver_id  references  tab_driver  d_id       this  source  code  was  highlighted  with  source  code  highlighterпервичн  ключ  primary  key  на  два  пол  гарантир  выполнен  всех  необходим  услов  содержан  пол  кажд  в  отдельн  не  может  быт  пуст  и  кажд  взаимосвяз  будет  уникальн  кром  тог  так  подход  позволя  избав  от  дополнительн  пол  и  обеспечива  автоматическ  индексац  для  создан  удален  и  выборк  взаимосвяз  в  пример  будут  использова  процедур    для  удобств  тестирован  кром  тог  мне  был  интересн  тестирован  имен  процедур  пот  что  с  точк  зрен  программирован  эт  удобн  чем  составля  запрос  в  тел  программ  необходим  отмет  что  нив  одн  процедур  нет  коммит  commit  во-перв  я  ег  при  тестирован  дела  вручн  во-втор  процедур  добавлен  и  удален  взаимосвяз  запуска  в  цикл  при  тестирован    в  так  случа  комм  будет  тольк  меша  create  procedure  add_relation     p_bus  number     p_driver  number     as  begin   insert  into  bus_driver  values    p_bus  p_driver    end  create  procedure  drop_relation     p_bus  number     p_driver  number     as  begin   delete  bus_driver  where  bus_id    p_bus  and  driver_id    p_driver  end  create  procedure  select_relation     p_data  out  sys_refcursor     as  begin   open  p_data  for    select  bbus_number  ddriver_name     from  tab_bus  b  tab_driver  d  bus_driver  r     where  bb_id    rbus_id  and  rdriver_id    dd_id  end    this  source  code  was  highlighted  with  source  code  highlighterвероятн  сто  отмет  что  зде  в  процедур  выборк  в  качеств  соединен  таблиц  join’а  использ  конструкц  where  на  эт  ест  две  причин  оракл  все  равн  он  счита  эт  join’ом  а  мне  удобн  сравнива  сложност  построен  sql  запрос  выборк  на  эт  создан  перв  структур  взаимосвяз  законч  был  реализова  след  схем  взаимосвяз  две  таблиц  и  дополнительн  таблиц  в  котор  хран  список  взаимосвяз  дал  идет  sql  код  альтернативн  вариант  втор  вариант  создава  на  точн  так  же  структур  таблиц  но  в  друг  схем  и  структур  взаимосвяз  выгляд  так  ест  две  таблиц  в  одн  из  них  кажд  зап  хран  список  взаимосвяз  таблиц  можн  создава  сраз  с  колон  вложен  таблиц  но  в  дан  случа  взаимосвяз  конструир  из  уж  готов  двух  таблиц  поэт  использ  друг  подход  одн  из  таблиц  изменя  create  or  replace  type  obj_list  as  object     r_driver  number     create  or  replace  type  nt_list  as  table  of  obj_list  alter  table  tab_bus  add     bus_drivers  nt_list  null     nested  table  bus_drivers  store  as  nt_bus_drivers    this  source  code  was  highlighted  with  source  code  highlighterкак  уж  упомина  внешн  ключ  во  вложен  таблиц  создава  нельз  поэт  имеет  смысл  написа  сво  велосипед  котор  несомнен  негативн  скажет  на  скорост  работ  с  взаимосвяз  create  function  check_fk     p_id number     return  number  is   fk_count  number  begin   select  countd_id  into  fk_count    from  tab_driver  where  d_id    p_id   return  fk_count  end    this  source  code  was  highlighted  with  source  code  highlighterи  наконец  процедур  создан  удален  и  выборк  для  взаимосвяз  тут  сто  отмет  блок  исключен  в  конц  процедур  дел  в  том  что  перв  значен  для  запис  необходим  добавля  использу  update  те  фактическ  меня  всю  ячейк  запис  зат  послед  взаимосвяз  добавля  уж  с  помощ  команд  insert  процедур  предполага  что  запис  уж  ест  а  в  случа  исключен  поступа  так  как  будт  связ  у  запис  нет  проверя  до  попытк  вставк  взаимосвяз  нет  смысл  так  как  эт  достаточн  мног  действ  есл  необходим  обрабатыва  и  друг  исключен  и  планир  писа  друг  код  на  общ  случа  то  след  уточн  обработк  исключен  добав  в  перемен  номер  исключен  и  уж  по  нем  производ  действ  create  procedure  add_relation     p_bus   number     p_driver number     as  begin   if  check_fkp_driver    1  then    insert  into  table       select  bus_drivers      from  tab_bus      where  b_id    p_bus         values    obj_listp_driver     else    raise_application_error-20665  'record  doesn''t  exist'   end  if   dbms_outputput_line  to_char  dbms_utilityget_time-start_time100  '0999'       exception    when  others  then     update  tab_bus      set  bus_drivers    nt_list    obj_listp_driver        where  b_id    p_bus  end  add_relation  create  procedure  drop_relation     p_bus   number     p_driver number     as  begin   if  check_fkp_driver    1  then    delete  table       select  bus_drivers      from  tab_bus  d      where  db_id    p_bus       nt      where  ntr_driver    p_bus     end  if   exception    when  others  then     null  end  drop_relation  create  procedure  select_relation     p_data  out  sys_refcursor     as  begin   open  p_data  for    select  bbus_number  ddriver_name     from  tab_bus  b  tab_driver  d  table  bbus_drivers  r     where  bb_id    p_bus  and  dd_id    p_driver  end    this  source  code  was  highlighted  with  source  code  highlighterпроцедур  удален  взаимосвяз  такж  имеет  обработк  исключен  так  как  он  происход  есл  таблиц  пуст  в  случа  исключен  нич  дела  не  над  так  как  иском  запис  уж  не  существ  что  для  процедур  удален  взаимосвяз  и  нужн  для  проверк  корректн  работ  процедур  был  использова  одинаков  тестов  значен  insert  into  tab_driver  values    seq_drivernextval  'viktor  jeliseev'  insert  into  tab_driver  values    seq_drivernextval  'stepan  kljavin'  insert  into  tab_driver  values    seq_drivernextval  'marija  baranka'  insert  into  tab_driver  values    seq_drivernextval  'arsenij  dubov'  insert  into  tab_bus  values    seq_busnextval  'p666pp'  insert  into  tab_bus  values    seq_busnextval  'lt-3216'  insert  into  tab_bus  values    seq_busnextval  'zox-15'  insert  into  tab_bus  values    seq_busnextval  'x234oo'  begin   add_relation  1  3   add_relation  1  4   add_relation  3  3   add_relation  3  2   add_relation  2  2   drop_relation  3  2   drop_relation  2  2  end  declare   g_data  sys_refcursor  begin   select_relation  1  4  g_data   select_relation  3  3  g_data   select_relation  2  2  g_data   select_relation  1  1  g_data  end    this  source  code  was  highlighted  with  source  code  highlighter  тестирован  тестирован  провод  нескольк  раз  для  кажд  вариант  снача  выборк  процедур  и  функц  был  отлаж  на  приведен  выш  тестов  дан  зат  был  созда  процедур  для  кажд  баз  дан  на  сам  дел  конечн  схем  котор  наполня  таблиц  дан  использу  генератор  случайн  чисел  примерн  так  же  образ  был  созда  зада  количеств  взаимосвяз  create  or  replace  procedure  random_insert_data     record_count  number     as   start_time  number  default  dbms_utilityget_time   counter  number   field_value  varchar2255  begin   for  counter  in  1record_count   loop    field_value    dbms_randomstring'a'  9    insert  into  tab_bus  b_id  bus_number  values       seq_busnextval       field_value        end  loop   for  counter  in  1record_count   loop    field_value    initcapdbms_randomstring'l'  6'  'initcapdbms_randomstring'l'  9    insert  into  tab_driver  values       seq_drivernextval       field_value   end  loop   dbms_outputput_line  to_char  dbms_utilityget_time-start_time100  '0999'      end  --  for  standart  many-to-many  relations  create  procedure  random_insert_rel     rel_count  number     rel_from number     rel_to  number     as   start_time  number  default  dbms_utilityget_time   rel1_value  varchar2255   rel2_value  varchar2255   counter  number  begin   for  counter  in  1rel_count   loop    rel1_value    rounddbms_randomvaluerel_from  rel_to    rel2_value    rounddbms_randomvaluerel_from  rel_to    add_relationrel1_value  rel2_value   end  loop   dbms_outputput_line  to_char  dbms_utilityget_time-start_time100  '0999'      end  --  for  standart  many-to-many  relations  create  procedure  random_delete_rel     rel_count  number     rel_from number     rel_to  number     as   start_time  number  default  dbms_utilityget_time   rel1_value  varchar2255   rel2_value  varchar2255   counter  number  begin   for  counter  in  1rel_count   loop    rel1_value    rounddbms_randomvaluerel_from  rel_to    rel2_value    rounddbms_randomvaluerel_from  rel_to    drop_relationrel1_value  rel2_value   end  loop   dbms_outputput_line  to_char  dbms_utilityget_time-start_time100  '0999'      end  --  for  alternative  many-to-many  system  with  nested  table  create  procedure  random_insert_rel     rel_count  number     rel_from number     rel_to  number     as   start_time  number  default  dbms_utilityget_time   rel1_value  varchar2255   rel2_value  varchar2255   counter  number  begin   for  counter  in  1rel_count   loop    rel1_value    rounddbms_randomvaluerel_from  rel_to    rel2_value    rounddbms_randomvaluerel_from  rel_to    add_relationrel1_value  rel2_value   end  loop   dbms_outputput_line  to_char  dbms_utilityget_time-start_time100  '0999'      end  --  for  alternative  many-to-many  system  with  nested  table  create  procedure  random_delete_rel     rel_count  number     rel_from number     rel_to  number     as   start_time  number  default  dbms_utilityget_time   rel1_value  varchar2255   rel2_value  varchar2255   counter  number  begin   for  counter  in  1rel_count   loop    rel1_value    rounddbms_randomvaluerel_from  rel_to    rel2_value    rounddbms_randomvaluerel_from  rel_to    drop_relationrel1_value  rel2_value   end  loop   dbms_outputput_line  to_char  dbms_utilityget_time-start_time100  '0999'      end    this  source  code  was  highlighted  with  source  code  highlighterобрат  внимен  в  процедур  для  тестирован  тож  нет  коммит  результат  тестирован  провод  на  дан  в  количеств  n    4  1000  100000  подразумева  что  в  кажд  таблиц  существ  n  запис  а  такж  созда  n  взаимосвяз  тестирован  провод  по  10  позиц  ниж  в  таблиц  представл  6  из  них  котор  имеют  наибол  существен  различ  по  времен  и  отобража  наибол  существен  дан  при  тестирован  провод  различ  межд  перв  выборк  и  послед  а  такж  межд  выборк  с  помощ  запрос  ил  с  помощ  процедур  котор  помеща  дан  в  курсор  основн  замер  произовод  для  создан  взаимосвяз  и  разн  вариант  выборок  удален  взаимосвяз  в  этот  перечен  не  вошл  так  как  использ  генератор  случайн  чисел  и  велик  вероятн  что  практическ  все  попытк  удален  взаимосвяз  обернут  бездейств  способ  запис  выборк  1  выборк  2  выборк  3  выборк  4  выборк  5  создан  доп  таблиц  4  00844  00792  00967  0001  0002  00032  в  таблиц  4  00694  00707  00026  0000  0000  00034  доп  таблиц  1000  00642  00645  00698  0002  0002  00142  в  таблиц  1000  00687  00695  00344  0000  0000  00721  доп  таблиц  100000  00648  00697  01323  0014  0049  14613  в  таблиц  100000  00741  00829  01117  0000  0000  84630  врем  указа  в  секунд  выборк  1  выборк  одн  взаимосвяз  из  анонимн  блок  в  курсор  с  использован  связа  перемен  выборк  2  выборк  одн  взаимосвяз  процедур  с  использован  связа  перемен  выборк  3  выборк  взаимосвяз  из  анонимн  блок  в  курсор  выборк  4  перв  выборк  всех  взаимосвяз  процедур  в  курсор  выборк  5  послед  выборк  всех  взаимосвяз  процедур  в  курсор  добавлен  врем  на  добавлен  n  взаимосвяз  хотел  бы  сказа  что  есл  реч  едет  об  1-2  секунд  то  врем  вообщ  не  важн  но  тут  след  учитыва  то  что  предполага  что  либ  реальн  баз  дан  будет  больш  либ  сервер  будет  бол  слаб  то  что  сервер  на  котор  тестирова  об  вариант  явля  достаточн  мощн  такж  имеет  сво  минус  слишк  больш  дол  времен  занима  побочн  операц  из-з  чег  сложн  провод  сравнен  на  маленьк  количеств  дан  итак  добавлен  взаимосвяз  в  альтернативн  вариант  занима  намн  больш  в  6  раз  времен  чем  в  стандартн  что  определен  указыва  на  то  что  альтернативн  вариант  не  подход  для  случа  когд  в  ден  над  создава  и  разруша  мног  бол  500  связ  есл  так  действ  меньш  то  с  точк  человек  разниц  будет  прост  незаметн  несмотр  на  лишн  действ  так  как  зам  проверк  внешн  ключ  тепер  о  выборк  выборк  из  анонимн  блок  занима  чут  больш  половин  секунд  во  всех  случа  вероятн  дел  в  том  что  основн  врем  уход  на  работ  с  сам  курсор  а  вот  при  выборк  больш  объем  дан  например  всех  вложен  таблиц  станов  бол  эффективн  почт  проход  меньш  времен  и  единствен  вариант  когд  альтернативн  вариант  медлен  эт  перв  выборк  всех  дан  и  наконец  последн  сравнен  сравнен  запрос  личн  я  не  виж  достойн  упоминан  различ  select  bbus_number  ddriver_name  from  tab_bus  b  tab_driver  d   bus_driver  r  where  bb_id    rbus_id   and  rdriver_id    dd_id  select  bbus_number  ddriver_name  from  tab_bus  b  tab_driver  d   table  bbus_drivers  r  where  bb_id    p_bus   and  dd_id    p_driver  вывод  в  цел  иде  создан  взаимосвяз  многие-ко-мног  использу  вложен  таблиц  оказа  не  так  безнадежн  как  каза  снача  несмотр  на  то  что  операц  создан  и  удален  взаимосвяз  занима  на  порядок  больш  времен  выборк  даж  больш  запрос  станов  быстр  а  сам  структур  запрос  по  сложност  приблизительн  одинаков  по  сложност  код  выборк  об  подход  одинаков  прост  а  вот  для  создан  ил  удален  взаимосвяз  он  сложн  для  альтернативн  подход  взаимосвяз  не  сто  реализовыва  с  помощ  вложен  таблиц  есл  необходим  част  и  мног  их  создава  ил  удаля  затрачива  слишк  мног  времен  таблиц  в  цел  мал  ил  структур  баз  дан  в  цел  прост  взаимосвяз  будет  занима  слишк  мног  времен  на  написан  процедур  их  добавлен  и  удален  логик  дан  подразумеват  равноцен  связыва  объект  нельз  реш  в  как  таблиц  создава  колон  взаимосвяз  имеет  смысл  задума  о  реализац  взаимосвяз  альтернативн  способ  есл  одн  таблиц  связан  по  принцип  многие-ко-мног  с  нескольк  друг  упроща  пониман  структур  и  логик  дан  взаимосвяз  созда  и  удаля  достаточн  редк  и  в  одн  и  связуем  таблиц  запис  удаля  и  добавля  не  слишк  част  нет  потер  в  скорост  работ  для  работ  с  баз  использ  тольк  процедур  представлен  и  возможн  выборк  ест  необходим  реализова  внешн  ключ  на  нескольк  таблиц  а  не  на  одн  бол  изящн  решен  в  отлич  от  создан  нескольк  колон  тем  бол  что  функц  проверк  соответсв  идентификатор  пол  нужн  в  люб  случа  