добр  времен  суток  хабрапараноик  сегодн  мы  поговор  о  немн  необычн  способ  повышен  безопасн  а  имен  замедлен  хеширован  парол  каза  бы  когд  все  вокруг  стара  оптимизирова  зач  что  то  замедля  хот  бы  зат  что  даж  в  сам  супер-пупер  защищен  систем  сам  слаб  звен  оста  человек  а  имен  ег  парол  вы  пыта  когд  нибуд  взлома  зашифрова  rar  арх  и  скольк  парол  в  секунд  он  перебира  50-100-200  даж  на  хорош  gpu  при  использован  небезызвестн  crark  скорост  перебор  всег  окол  2400  вариантовсек  и  это-т  по  сравнен  с  десятк  сотн  миллион  паролейсек  для  zipmd5sha1  под  кат  мо  вольн  интерпретац  эт  процесс  смысл  всег  действ  свод  к  след  ключ  шифрован  важн  явля  не  парол  а  медлен  хэш  от  нег  юзер  нич  не  сто  подожда  секундупол  секунд  пок  парол  прохешир  а  вот  homo  brutforsus  придет  запаст  терпен  да  чут  не  заб  про  всем  любим  rainbow  tables  котор  довольн  успешн  генер  даж  для  сист  использ  сахар  сол  их  генерац  тож  станет  есл  не  бесполезн  то  очен  трудозатратн  я  не  говор  что  систем  с  сол  плох  прост  их  можн  ещ  усил  и  так  ест  сол  ест  парол  что  дальш  а  дальш  все  довольн  прост  конкатениру  сол  и  парол  хэширу  запомина  результат  while  мног  мног  раз  do{  сгенерирова  раундов  сол  сконкатенирова  е  и  хэш  прохэширова  запомн  результат}  в  winrar  спасиб  ем  кстат  за  вдохновен  есл  мне  не  изменя  памя  раундов  сол  явля  номер  итерац  я  же  пошел  немножк  дальш  итак  код  все  написа  на  java  с  использован  библиотек  bouncycastle  но  вдумчив  хабрапараноик  не  состав  сложност  перенест  эт  и  может  быт  добав  сво  на  люб  язык  программирован  полн  по  тьюринг  к  том  же  bouncycastle  ест  и  для  c#  1  я  использ  2  алгоритм  хеширован  sha-256  и  sha-512  поэт  для  нача  небольш  интерфейсик  котор  поможет  нам  все  эт  дел  более-мен  универсализирова  public  interface  idigest  {      public  byte  processbyte  data            public  int  getsize  }  2  пример  реализац  эт  интерфейс  для  алгоритм  sha-256  использ  класс  sha256digest  из  библиотек  bouncycastle  public  class  sha256  implements  idigest  {      private  sha256digest  m_sha256    new  sha256digest      @override      public  byte  processbyte  data      {          m_sha256reset          m_sha256updatedata  0  datalength          byte  result    new  bytem_sha256getdigestsize          m_sha256dofinalresult  0          return  result      }      @override      public  int  getsize      {          return  m_sha256getdigestsize      }  }  3  сам  вкуснятин  е  я  объясн  подробн  public  class  slowhasher  {      private  final  static  int  bits_in_byte    8            private  static  final  int  s_primeindices    new  int  {  7  11  17  23  31  41  47  53  61  }                this  method  hashes  password  0x50000  times  adding  round  salt  each  round                  param  digest          param  password          return              public  byte  calculateslowhashidigest  digest  string  password  byte  salt      {          int  roundsaltsize    digestgetsize    bits_in_byte          byte  bpasswd    passwordgetbytes          byte  tohash    new  bytebpasswdlength  +  saltlength                        composing  array  of  bytes  that  will  be  hashed                      systemarraycopysalt  0  tohash  0  saltlength          systemarraycopybpasswd  0  tohash  saltlength  bpasswdlength          byte  res    digestprocesstohash          byte  temp    new  bytereslength  +  roundsaltsize          for  int  i    0  i    0x50000  i++          {              systemarraycopyres  0  temp  0  reslength                               calculating  salt                              for  int  j    0  j    roundsaltsize  j++              {                  int  btmp    ress_primeindicesj  &  0xff                  for  int  k    1  k    bits_in_byte  k++                  {                      btmp    rorbtmp  +  resrorbtmp  k    reslength  &  0xff    256  bits_in_byte-k                  }                  tempreslength  +  j    bytebtmp              }              res    digestprocesstemp          }          return  res      }               rotate  bits  right  treating  input  as  byte          param  value  0    value  255          param  n  number  of  bits  to  shift          return              public  static  int  rorint  value  int  n      {          return  value    n    bits_in_byte    value    8    n    bits_in_byte  &  0xff      }  }  люд  не  знаком  с  java  скаж  сраз  что  не  сто  пуга  многочислен  вставок  &  0xff  эт  всег  лиш  конвертац  signed  byte  в  unsigned  пут  преобразован  ег  в  int  и  применен  так  вот  битов  маск  а  все  пот  что  в  java  нет  unsigned  тип  совс  ну  да  ладн  эт  не  смертельн  вся  красив  тут  заключа  в  формирован  раундов  сол  поэт  основн  вниман  будет  уделя  е  немн  о  перемен  res    масс  из  32  байт  для  sha-256  ил  64  байт  для  sha-512  в  нем  хран  результат  хеширован  roundsaltsize    размер  раундов  сол  4  байт  для  sha-256  и  8  байт  для  sha-512  temp    масс  из  элемент  размер  массив  res  плюс  размер  раундов  сол  roundsaltsize  s_primeindices    масс  индекс  элемент  в  массив  res  начин  с  котор  мы  буд  вычисля  соответств  байт  раундов  сол  то  ест  начина  вычислен  перв  байт  раундов  сол  для  sha-256  мы  буд  с  res7  втор  с  res11  и  тд  для  sha-512  будут  задействова  все  индекс  btemp    байт  котор  посл  сер  хитр  преобразован  станет  на  сво  мест  в  раундов  сол  ещ  одн  ремарк  прежд  чем  мы  перейд  к  разъяснен  формирован  алгоритм  раундов  сол  ве  алгоритм  не  явля  результат  как  либ  научн  исследован  и  тест  он  созда  для  формирован  значен  котор  был  бы  зависим  от  некотор  байт  результир  хэш  и  помогл  бы  ег  замедл  и  усложн  ну  а  тепер  описан  в  начал  в  масс  tohash  собира  основн  сол  и  парол  масс  tohash  хешир  и  результат  запомина  в  массив  res  все  про  основн  сол  и  парол  заб  запуска  длин  цикл  в  0x50000  итерац  дал  работа  с  массив  temp  в  котор  копиру  масс  res  в  конц  массив  temp  ещ  оста  4  ил  8  байт  для  сол  нам  предсто  их  заполн  для  кажд  из  байт  раундов  сол  запомина  в  btmp  элемент  котор  наход  по  одн  из  индекс  7  11  17    в  зависим  от  номер  текущ  байт  j  зат  7k  раз  дела  след  бер  остаток  от  делен  btmp  у  котор  бит  сдвинут  вправ  на  k  позиц  на  длин  массив  res  предыдущ  числ  использу  как  индекс  для  массив  res  вытаскива  числ  по  эт  индекс  btmp  присваива  эт  числ  сложен  с  btmp  по  модул  256  и  прокручен  вправ  на  8-k  бит  помеща  btmp  на  сво  мест  посл  хэш  в  массив  temp  хэширу  temp  выз  эт  метод  выгляд  след  образ  byte  salt    new  byte16  new  securerandomnextbytessalt    generate  random  16byte  salt  byte  hashedpassword    new  slowhashercalculateslowhashnew  sha256  password  salt  в  результат  получ  хэшхэшхэш+ранудов  соль+раундов  сол  котор  можн  использова  как  256  битн  ключ  шифрован  важн  информац  для  aes-256  например  на  мо  машин  c2d  26  на  генерац  одн  хэш  приход  окол  025  секунд  что  я  счита  приемлем  для  использован  в  сво  проект  можн  увелич  числ  раунд  и  тогд  врем  соответствен  вырастет  есл  уважа  публик  будет  интересн  то  я  мог  рассказа  и  о  друг  прикладн  аспект  работ  с  библиотек  bouncycastle  как  то  симметричноеассиметричн  шифрован  генерац  сертификат  и  тд  upd  в  коммент  указа  ссылк  на  док  в  котор  так  род  схем  принима  ещ  больш  разм  