Польза от вложенных таблиц, или, как их ещё называют, дочерних таблиц (NESTED TABLE) достаточно сомнительна по двум причинам: для типов и объектов нельзя создать внешние ключи (FOREIGN KEY), а реализовать функционал с помощью дополнительной таблицы очень просто. И можно было бы найти другие достоинства для вложенных таблиц, если бы не тот факт, что после создания основной таблицы колонну вложенной таблицы изменить уже нельзя. Можно, конечно, создать второй тип и использовать его, но это достаточно большое количество работы и, несомненно, много беспокойства о уже существующих данных. Однако у меня возникла идея о реализации взаимосвязи многие-ко-многим (MANY-TO-MANY RELATIONSHIP) с помощью вложенной таблицы, ведь идея так заманчива — вместо одного внешнего ключа хранить их набор для конкретной записи — что может быть логичнее с точки зрения человеческой логики? Но тут возник вопрос — а стоит ли игра свеч? Пример На примере проще показать предлагаемую структуру, а также это хороший способ проверить, какой способ меньше нагружает систему. Допустим, существует автобусный парк, сферический в вакууме. У автобусного парка есть несколько автобусов и несколько водителей. На одном автобусе ездят несколько водителей (несколько смен). Особенности этого парка таковы, что один водитель также может ездить на нескольких автобусах, например, в зависимости от дня недели. Создадим две очень простые таблицы, предназначенные только для того, чтобы создавать между ними взаимосвязи. CREATE TABLE tab_bus  ( b_id NUMBER PRIMARY KEY  , bus_number VARCHAR2(9) NOT NULL  ); CREATE SEQUENCE seq_bus; CREATE TABLE tab_driver  ( d_id NUMBER PRIMARY KEY  , driver_name VARCHAR2(255) NOT NULL  ); CREATE SEQUENCE seq_driver; * This source code was highlighted with Source Code Highlighter.Для начала реализуем взаимосвязь использую наиболее распространённый подход: создадим таблицу взаимосвязей. CREATE TABLE bus_driver  ( bus_id NUMBER  , driver_id NUMBER  , CONSTRAINT pk_driver_bus PRIMARY KEY (bus_id, driver_id)  , CONSTRAINT fk_bus_id FOREIGN KEY (bus_id) REFERENCES tab_bus (b_id)  , CONSTRAINT fk_driver_id FOREIGN KEY (driver_id) REFERENCES tab_driver (d_id)  ); * This source code was highlighted with Source Code Highlighter.Первичный ключ (PRIMARY KEY) на два поля гарантирует выполнение всех необходимых условий: содержание полей (каждого в отдельности) не может быть пустым и каждая взаимосвязь будет уникальна. Кроме того, такой подход позволяет избавится от дополнительных полей и обеспечивает автоматическую индексацию. Для создания, удаления и выборки взаимосвязей в примере будут использованы процедуры — для удобства тестирования. Кроме того, мне было интересно тестирование именно процедурами, потому что с точки зрения программирования это удобнее, чем составлять запросы в теле программы. Необходимо отметить, что нив одной процедуре нет коммита (COMMIT;). Во-первых я его при тестировании делаю вручную, во-вторых процедуры добавления и удаления взаимосвязей запускаются в цикле при тестировании — в таком случае коммит будет только мешать. CREATE PROCEDURE add_relation  ( p_bus NUMBER  , p_driver NUMBER  ) AS BEGIN  INSERT INTO bus_driver VALUES ( p_bus, p_driver ); END; CREATE PROCEDURE drop_relation  ( p_bus NUMBER  , p_driver NUMBER  ) AS BEGIN  DELETE bus_driver WHERE bus_id = p_bus AND driver_id = p_driver; END; CREATE PROCEDURE select_relation  ( p_data OUT SYS_REFCURSOR  ) AS BEGIN  OPEN p_data FOR   SELECT b.bus_number, d.driver_name    FROM tab_bus b, tab_driver d, bus_driver r    WHERE (b.b_id = r.bus_id) AND (r.driver_id = d.d_id); END; * This source code was highlighted with Source Code Highlighter.Вероятно, стоит отметить, что здесь в процедуре выборки в качестве соединения таблиц (JOIN’а) используется конструкция WHERE. На это есть две причины: ораклу всё равно, он считает это JOIN’ом, а мне удобнее сравнивать сложность построения SQL запросов выборки. На этом создание первой структуры взаимосвязи закончено. Была реализована следующая схема взаимосвязи: две таблицы и дополнительная таблица, в которой хранится список взаимосвязей. Далее идёт SQL код альтернативного варианта. Второй вариант создавался на точно такой же структуре таблиц, но в другой схеме. И структура взаимосвязей выглядит так: есть две таблицы, в одной из них каждая запись хранит список взаимосвязей. Таблицу можно создавать сразу с колонной вложенных таблиц, но в данном случае взаимосвязь конструируется из уже готовых двух таблиц, поэтому используется другой подход: одна из таблиц изменяется. CREATE OR REPLACE TYPE obj_list AS OBJECT  ( r_driver NUMBER  ); CREATE OR REPLACE TYPE nt_list AS TABLE OF obj_list; ALTER TABLE tab_bus ADD  ( bus_drivers nt_list NULL  ) NESTED TABLE bus_drivers STORE AS nt_bus_drivers; * This source code was highlighted with Source Code Highlighter.Как уже упоминалось, внешние ключи во вложенных таблицах создавать нельзя, поэтому имеет смысл написать свой велосипед, который, несомненно, негативно скажется на скорости работы с взаимосвязями. CREATE FUNCTION check_fk  ( p_id NUMBER  ) RETURN NUMBER IS  fk_count NUMBER; BEGIN  SELECT COUNT(d_id) INTO fk_count   FROM tab_driver WHERE d_id = p_id;  RETURN fk_count; END; * This source code was highlighted with Source Code Highlighter.И, наконец, процедуры создания, удаления и выборки для взаимосвязей. Тут стоит отметить блоки исключения в конце процедур. Дело в том, что первое значение для записи необходимо добавлять используя UPDATE, т.е. фактически менять всю ячейку записи. Зато последующие взаимосвязи добавляются уже с помощью команды INSERT. Процедура предполагает, что записи уже есть, а в случае исключения поступает так, как будто связей у записи нет. Проверять до попытки вставки взаимосвязи нет смысла, так как это достаточно много действий. Если необходимо обрабатывать и другие исключения и планируется писать другой код на общий случай, то следует уточнить обработку исключения, добавить в переменные номер исключения и уже по нему производить действие. CREATE PROCEDURE add_relation  ( p_bus  NUMBER  , p_driver NUMBER  ) AS BEGIN  IF (check_fk(p_driver) = 1) THEN   INSERT INTO TABLE    ( SELECT bus_drivers     FROM tab_bus     WHERE b_id = p_bus    )   VALUES ( obj_list(p_driver) );  ELSE   RAISE_APPLICATION_ERROR(-20665, 'Record doesn''t exist.');  END IF;  DBMS_OUTPUT.PUT_LINE( TO_CHAR( (DBMS_UTILITY.GET_TIME-start_time)/100, '09.99' ) );  EXCEPTION   WHEN OTHERS THEN    UPDATE tab_bus     SET bus_drivers = nt_list ( obj_list(p_driver) )     WHERE b_id = p_bus; END add_relation; CREATE PROCEDURE drop_relation  ( p_bus  NUMBER  , p_driver NUMBER  ) AS BEGIN  IF (check_fk(p_driver) = 1) THEN   DELETE TABLE    ( SELECT bus_drivers     FROM tab_bus d     WHERE d.b_id = p_bus    ) nt    WHERE nt.r_driver = p_bus;   END IF;  EXCEPTION   WHEN OTHERS THEN    NULL; END drop_relation; CREATE PROCEDURE select_relation  ( p_data  OUT SYS_REFCURSOR  ) AS BEGIN  OPEN p_data FOR   SELECT b.bus_number, d.driver_name    FROM tab_bus b, tab_driver d, TABLE (b.bus_drivers) r    WHERE (b.b_id = p_bus) AND (d.d_id = p_driver); END; * This source code was highlighted with Source Code Highlighter.Процедура удаления взаимосвязи также имеет обработку исключения, так как оно происходит, если таблица пуста. В случае исключения ничего делать не надо, так как искомой записи уже не существует, что для процедуры удаления взаимосвязи и нужно. Для проверки корректности работы процедур были использованы одинаковые тестовые значения. INSERT INTO tab_driver VALUES ( seq_driver.NEXTVAL, 'Viktor Jeliseev'); INSERT INTO tab_driver VALUES ( seq_driver.NEXTVAL, 'Stepan Kljavin'); INSERT INTO tab_driver VALUES ( seq_driver.NEXTVAL, 'Marija Baranka'); INSERT INTO tab_driver VALUES ( seq_driver.NEXTVAL, 'Arsenij Dubov'); INSERT INTO tab_bus VALUES ( seq_bus.NEXTVAL, 'p666pp'); INSERT INTO tab_bus VALUES ( seq_bus.NEXTVAL, 'LT-3216'); INSERT INTO tab_bus VALUES ( seq_bus.NEXTVAL, 'zox-15'); INSERT INTO tab_bus VALUES ( seq_bus.NEXTVAL, 'x234oo'); BEGIN  add_relation (1, 3);  add_relation (1, 4);  add_relation (3, 3);  add_relation (3, 2);  add_relation (2, 2);  drop_relation (3, 2);  drop_relation (2, 2); END; DECLARE  g_data SYS_REFCURSOR; BEGIN  select_relation (1, 4, g_data);  select_relation (3, 3, g_data);  select_relation (2, 2, g_data);  select_relation (1, 1, g_data); END; * This source code was highlighted with Source Code Highlighter. Тестирование Тестирование проводилось несколько раз для каждого варианта. Сначала выборки, процедуры и функция были отлажены на приведённых выше тестовых данных. Затем были созданы процедуры для каждой базы данных (на самом деле, конечно, схемы), которые наполняли таблицы данными, используя генератор случайных чисел. Примерно таким же образом было создано заданное количество взаимосвязей. CREATE OR REPLACE PROCEDURE random_insert_data  ( record_count NUMBER  ) AS  start_time NUMBER DEFAULT DBMS_UTILITY.GET_TIME;  counter NUMBER;  field_value VARCHAR2(255); BEGIN  FOR counter IN 1..record_count  LOOP   field_value := DBMS_RANDOM.STRING('A', 9);   INSERT INTO tab_bus (b_id, bus_number) VALUES    ( seq_bus.NEXTVAL    , field_value    );  END LOOP;  FOR counter IN 1..record_count  LOOP   field_value := INITCAP(DBMS_RANDOM.STRING('L', 6))||' '||INITCAP(DBMS_RANDOM.STRING('L', 9));   INSERT INTO tab_driver VALUES    ( seq_driver.NEXTVAL    , field_value);  END LOOP;  DBMS_OUTPUT.PUT_LINE( TO_CHAR( (DBMS_UTILITY.GET_TIME-start_time)/100, '09.99' ) ); END; -- for standart many-to-many relations CREATE PROCEDURE random_insert_rel  ( rel_count NUMBER  , rel_from NUMBER  , rel_to  NUMBER  ) AS  start_time NUMBER DEFAULT DBMS_UTILITY.GET_TIME;  rel1_value VARCHAR2(255);  rel2_value VARCHAR2(255);  counter  NUMBER; BEGIN  FOR counter IN 1..rel_count  LOOP   rel1_value := ROUND(DBMS_RANDOM.VALUE(rel_from, rel_to));   rel2_value := ROUND(DBMS_RANDOM.VALUE(rel_from, rel_to));   add_relation(rel1_value, rel2_value);  END LOOP;  DBMS_OUTPUT.PUT_LINE( TO_CHAR( (DBMS_UTILITY.GET_TIME-start_time)/100, '09.99' ) ); END; -- for standart many-to-many relations CREATE PROCEDURE random_delete_rel  ( rel_count NUMBER  , rel_from NUMBER  , rel_to  NUMBER  ) AS  start_time NUMBER DEFAULT DBMS_UTILITY.GET_TIME;  rel1_value VARCHAR2(255);  rel2_value VARCHAR2(255);  counter  NUMBER; BEGIN  FOR counter IN 1..rel_count  LOOP   rel1_value := ROUND(DBMS_RANDOM.VALUE(rel_from, rel_to));   rel2_value := ROUND(DBMS_RANDOM.VALUE(rel_from, rel_to));   drop_relation(rel1_value, rel2_value);  END LOOP;  DBMS_OUTPUT.PUT_LINE( TO_CHAR( (DBMS_UTILITY.GET_TIME-start_time)/100, '09.99' ) ); END; -- for alternative many-to-many system with nested table CREATE PROCEDURE random_insert_rel  ( rel_count NUMBER  , rel_from NUMBER  , rel_to  NUMBER  ) AS  start_time NUMBER DEFAULT DBMS_UTILITY.GET_TIME;  rel1_value VARCHAR2(255);  rel2_value VARCHAR2(255);  counter  NUMBER; BEGIN  FOR counter IN 1..rel_count  LOOP   rel1_value := ROUND(DBMS_RANDOM.VALUE(rel_from, rel_to));   rel2_value := ROUND(DBMS_RANDOM.VALUE(rel_from, rel_to));   add_relation(rel1_value, rel2_value);  END LOOP;  DBMS_OUTPUT.PUT_LINE( TO_CHAR( (DBMS_UTILITY.GET_TIME-start_time)/100, '09.99' ) ); END; -- for alternative many-to-many system with nested table CREATE PROCEDURE random_delete_rel  ( rel_count NUMBER  , rel_from NUMBER  , rel_to  NUMBER  ) AS  start_time NUMBER DEFAULT DBMS_UTILITY.GET_TIME;  rel1_value VARCHAR2(255);  rel2_value VARCHAR2(255);  counter  NUMBER; BEGIN  FOR counter IN 1..rel_count  LOOP   rel1_value := ROUND(DBMS_RANDOM.VALUE(rel_from, rel_to));   rel2_value := ROUND(DBMS_RANDOM.VALUE(rel_from, rel_to));   drop_relation(rel1_value, rel2_value);  END LOOP;  DBMS_OUTPUT.PUT_LINE( TO_CHAR( (DBMS_UTILITY.GET_TIME-start_time)/100, '09.99' ) ); END; * This source code was highlighted with Source Code Highlighter.Обратите внимение, в процедурах для тестирования тоже нет коммита. Результаты Тестирование проводилось на данных в количестве n = 4, 1000, 100000. Подразумевается, что в каждой таблице существует n записей, а также создано n взаимосвязей. Тестирование проводилось по 10 позициям, ниже в таблице представлены 6 из них, которые имеют наиболее существенные различия по времени и отображают наиболее существенные данные. При тестировании проводилось различие между первой выборкой и последующими, а также между выборкой с помощью запроса или с помощью процедуры, которая помещает данные в курсор. Основные замеры произоводились для создания взаимосвязей и разных вариантов выборок. Удаление взаимосвязей в этот перечень не вошло, так как используется генератор случайных чисел и велика вероятность, что практически все попытки удаления взаимосвязей обернутся бездействием. способ, записи выборка 1 выборка 2 выборка 3 выборка 4 выборка 5 создание доп. таблица, 4 00.844 00.792 00.967 00.01 00.02 00.032 в. таблица, 4 00.694 00.707 00.026 00.00 00.00 00.034 доп. таблица, 1000 00.642 00.645 00.698 00.02 00.02 00.142 в. таблица, 1000 00.687 00.695 00.344 00.00 00.00 00.721 доп. таблица, 100000 00.648 00.697 01.323 00.14 00.49 14.613 в. таблица, 100000 00.741 00.829 01.117 00.00 00.00 84.630 Время указано в секундах. Выборка 1: выборка одной взаимосвязи из анонимного блока в курсор, с использование связанных переменных. Выборка 2: выборка одной взаимосвязи процедурой, с использованием связанных переменных. Выборка 3: выборка взаимосвязей из анонимного блока в курсор. Выборка 4: первая выборка всех взаимосвязей процедурой в курсор. Выборка 5: последующие выборки всех взаимосвязей процедурой в курсор. Добавление: время на добавление n взаимосвязей. Хотелось бы сказать, что если речь едёт об 1-2 секундах, то время вообще не важно, но тут следует учитывать то, что предполагается, что либо реальная база данных будет большой, либо сервер будет более слабым. То, что сервер, на котором тестировались оба варианта, является достаточно мощным также имеет свой минус: слишком большую долю времени занимают побочные операции, из-за чего сложно проводить сравнения на маленьком количестве данных. Итак, добавление взаимосвязи в альтернативном варианте занимает намного больше (в 6 раз) времени, чем в стандартном, что определённо указывает на то, что альтернативный вариант не подходит для случаев, когда в день надо создавать и разрушать много (более 500) связей. Если таких действий меньше, то с точки человека разница будет просто незаметна, несмотря на лишние действия, такие как замены проверки внешнего ключа. Теперь о выборке. Выборка из анонимного блока занимает чуть больше половины секунды во всех случаях. Вероятно дело в том, что основное время уходит на работу с самим курсором. А вот при выборке большого объёма данных (например, всех), вложенная таблицы становится более эффективной: почти проходит меньше времени и единственный вариант, когда альтернативный вариант медленнее, это первая выборка всех данных. И, наконец, последнее сравнение: сравнение запросов. Лично я не вижу достойных упоминания различий. SELECT b.bus_number, d.driver_name FROM tab_bus b, tab_driver d,  bus_driver r WHERE (b.b_id = r.bus_id)  AND (r.driver_id = d.d_id); SELECT b.bus_number, d.driver_name FROM tab_bus b, tab_driver d,  TABLE (b.bus_drivers) r WHERE (b.b_id = p_bus)  AND (d.d_id = p_driver); Выводы В целом идея создания взаимосвязей многие-ко-многим используя вложенные таблицы оказалось не такой безнадёжной, как казалось сначала. Несмотря на то, что операции создания и удаления взаимосвязей занимают на порядок больше времени, выборка даже больших запросов становится быстрее, а сама структура запроса по сложности приблизительно одинакова. По сложности кода выборки оба подхода одинаково просты, а вот для создания или удаления взаимосвязи он сложнее для альтернативного подхода. Взаимосвязь не стоит реализовывать с помощью вложенной таблицы, если: Необходимо часто и много их создавать или удалять (затрачивается слишком много времени); Таблиц в целом мало или структура базы данных в целом проста (взаимосвязь будет занимать слишком много времени на написание процедур их добавления и удаления); Логика данных подразумеват равноценность связываемых объектов (нельзя решить, в какой таблице создавать колонну взаимосвязей). Имеет смысл задуматься о реализации взаимосвязи альтернативным способом, если Одна таблица связанна по принципу многие-ко-многим с несколькими другими (упрощает понимание структуры и логики данных); Взаимосвязи создаются и удаляются достаточно редко и в одной и связуемых таблиц записи удаляются и добавляются не слишком часто (нет потери в скорости работы); Для работы с базой используется только процедуры, представления и, возможно, выборка; Есть необходимость реализовать внешний ключ на несколько таблиц, а не на одну (более изящное решение, в отличие от создания нескольких колонн, тем более, что функция проверки соответсвия идентификатора поля нужна в любом случае).